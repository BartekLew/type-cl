(let ((fns (make-hash-table)))
  (defun fn (name)
    (or (gethash name fns)
        (error "Function not found: ~A." name)))
  (defun (setf fn) (def name type-spec)
    (loop for d in (gethash name fns)
          do (if (equalp (first d) type-spec)
               (error "Function already defined ~A : ~A~%"
                      name type-spec)))
    (setf (gethash name fns)
            (cons (list type-spec def)
                  (gethash name fns)))
    (defmethod print-object ((this (eql def)) out)
        (format out "#<~A ~A>" name type-spec))))

(let ((types (make-hash-table)))
  (defun check (name value)
    (if (not name) (return-from check value))
    (let ((checker (gethash (if (listp+ name)
                               (first name) 
                               name)
                            types)))
      (if (not checker) (error "Type checker not found: ~A." name))
      (apply checker (if (listp+ name)
                        (cons value (rest name))
                        (list value)))))
  (defun (setf check) (fn name)
    (if (gethash name types) (error "Type checker already defined: ~A" name))
    (setf (gethash name types) fn)))

(let ((casts (make-hash-table :test #'equalp)))
  (defun converter (from to)
    (let ((act (gethash `(,from ,to) casts)))
      (if (not act) (error "conversion not found: ~A -> ~A." from to))
      act))
  (defun (setf converter) (action from to)
    (if (gethash `(,from ,to) casts)
       (error "conversion already defined: A~ -> ~A" from to))
    (setf (gethash `(,from ,to) casts) action)))

(defun defprod (name)
  (setf (check name)
        (lambda (val)
          (declare (ignore val))
          (error 'call-type-mismatch := name))))

